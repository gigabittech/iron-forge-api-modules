"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:true});exports.init=init;exports.lock=lock;exports.lockWithRelationshipChecks=lockWithRelationshipChecks;const lodash_1=__importDefault(require("lodash"));let __isInitialized=false;let __tableLockingOrder=[];let __lockableTablesSet=new Set;let __disableMultiCallLockTracking=false;let __debug=false;const __trx2FinalLockedRow=new Map;function init({tableLockingOrder:tableLockingOrder,disableMultiCallLockTracking:disableMultiCallLockTracking,debug:debug}){if(__isInitialized){throw new Error("CANNOT_INIT_LOCK_MODULE_TWICE")}__isInitialized=true;__tableLockingOrder=tableLockingOrder;__lockableTablesSet=new Set(__tableLockingOrder);__disableMultiCallLockTracking=disableMultiCallLockTracking??false;__debug=debug??false}async function lock(trx,tableName2RowIds){await __internalLock(trx,tableName2RowIds)}async function __internalLock(trx,tableName2RowIds){if(__trx2FinalLockedRow.get(trx)){console.warn("WARNING__MULTIPLE_LOCK_CALLS_IN_TRANSACTION");console.warn("You are attempting to lock using multiple calls within the same transaction. "+"Though it is possible that this operation will succeed, this success may be unreliable "+"in that the same logic might fail for a different set of records. Please rewrite "+"the logic to use a single call to lock all necessary records.")}const cleanedTableName2RowIds=__cleanTableName2RowIds(tableName2RowIds);__validateTableNamesExistInLockingOrder(cleanedTableName2RowIds);const rowsToLock=__genRowsToLock(cleanedTableName2RowIds);if(rowsToLock.length===0){return}let finalLockedRow=undefined;if(!__disableMultiCallLockTracking){finalLockedRow=__validateOtherLocksInTransaction(trx,rowsToLock)}await __lockRows(trx,rowsToLock);return finalLockedRow}const __defaultMaxNumChecks=3;async function lockWithRelationshipChecks({trx:trx,tableName2RowIds:tableName2RowIds,fnGetRelatedIds:fnGetRelatedIds,options:options}){const print=__genDebugPrint(options?.debug??__debug);print({type:"functionName"});let relationshipChecksSucceeded=false;const maxNumChecks=!options?.disableRetryRelationshipChecks?options?.maxNumChecks??__defaultMaxNumChecks:1;let getRelatedIdsOutput=undefined;for(let numChecks=1;!relationshipChecksSucceeded&&numChecks<=maxNumChecks;++numChecks){const{tableName2RowIds:preRelationships}=await fnGetRelatedIds(trx);const merged=__mergeTableName2RowIdsObjects(preRelationships,tableName2RowIds);print({type:"lockAttempt",numChecks:numChecks,maxNumChecks:maxNumChecks,merged:merged});const previousFinalLockedRow=await __internalLock(trx,merged);const{tableName2RowIds:postRelationships,output:output}=await fnGetRelatedIds(trx);getRelatedIdsOutput=output;if(lodash_1.default.isEqual(preRelationships,postRelationships)){print({type:"attemptSucceeded"});relationshipChecksSucceeded=true}else{print({type:"attemptFailed",preRelationships:preRelationships,postRelationships:postRelationships});if(previousFinalLockedRow){__trx2FinalLockedRow.set(trx,previousFinalLockedRow)}else{__trx2FinalLockedRow.delete(trx)}}}if(!relationshipChecksSucceeded){throw new Error("LOCK_RELATIONSHIP_CHECKS_FAILED")}return getRelatedIdsOutput}function __genDebugPrint(debug){return message=>{if(!debug){return}if(message.type==="functionName"){console.debug("lockWithRelationshipChecks()")}else if(message.type==="lockAttempt"){console.debug(`--Lock attempt ${message.numChecks}/${message.maxNumChecks}`);console.debug(`    tableName2RowIds value for lock():`);console.debug(__formatObject(message.merged))}else if(message.type==="attemptSucceeded"){console.debug(`    Attempt succeeded`)}else if(message.type==="attemptFailed"){console.debug(`    Attempt failed`);console.debug(`    Pre-check:`);console.debug(__formatObject(message.preRelationships));console.debug(`    Post-check:`);console.debug(__formatObject(message.postRelationships))}}}function __formatObject(object){const fullString=JSON.stringify(object,null,2);const lines=fullString.split("\n");const indentedLines=lodash_1.default.map(lines,(line=>`      ${line}`));return indentedLines.join("\n")}function __cleanTableName2RowIds(input){const tableName2Strings=lodash_1.default.mapValues(input,(rowIdOrRowIds=>{const rowIds=lodash_1.default.isString(rowIdOrRowIds)||lodash_1.default.isUndefined(rowIdOrRowIds)||rowIdOrRowIds===null?[rowIdOrRowIds]:rowIdOrRowIds;const compactRowIds=lodash_1.default.compact(rowIds);const lowerRowIds=lodash_1.default.map(compactRowIds,(rowId=>rowId.toLowerCase()));return lodash_1.default.sortBy(lowerRowIds)}));return lodash_1.default.pickBy(tableName2Strings,(array=>array.length>0))}function __mergeTableName2RowIdsObjects(object1,object2){const cleanedObject1=__cleanTableName2RowIds(object1);const cleanedObject2=__cleanTableName2RowIds(object2);const allKeys=lodash_1.default.uniq([...lodash_1.default.keys(cleanedObject1),...lodash_1.default.keys(cleanedObject2)]);const merged=lodash_1.default.reduce(allKeys,((mergedObject,key)=>{mergedObject[key]=lodash_1.default.compact(lodash_1.default.uniq([...cleanedObject1[key]??[],...cleanedObject2[key]??[]]));return mergedObject}),{});return __cleanTableName2RowIds(merged)}function __validateTableNamesExistInLockingOrder(tableName2RowIds){const inputTableNames=lodash_1.default.keys(tableName2RowIds);const tablesNotInLockableTablesSet=lodash_1.default.filter(inputTableNames,(tableName=>!__lockableTablesSet.has(tableName)));if(tablesNotInLockableTablesSet.length>0){console.error(tablesNotInLockableTablesSet.join(", "));throw new Error("TABLE_NOT_IN_LOCKABLE_TABLES")}}function __sortInputTableNames(tableName2RowIds){const inputTableNamesSet=new Set(lodash_1.default.keys(tableName2RowIds));return lodash_1.default.compact(lodash_1.default.map(__tableLockingOrder,(orderTable=>inputTableNamesSet.has(orderTable)?orderTable:null)))}function __genRowsToLock(tableName2RowIds){const tableNamesInOrder=__sortInputTableNames(tableName2RowIds);return lodash_1.default.flatMap(tableNamesInOrder,(tableName=>lodash_1.default.map(tableName2RowIds[tableName],(rowId=>({tableName:tableName,id:rowId})))))}function __validateOtherLocksInTransaction(trx,rowsToLock){const finalLockedRow=__trx2FinalLockedRow.get(trx);if(finalLockedRow){const firstRowToLock=rowsToLock[0];if(firstRowToLock&&!__checkRowIsOrderedBeforeOrEqualToRow(finalLockedRow,firstRowToLock)){console.error(`Previous lock: ${finalLockedRow.tableName}[${finalLockedRow.id}]. Requested lock: ${firstRowToLock.tableName}[${firstRowToLock.id}].`);throw new Error("REQUESTED_LOCK_IS_OUT_OF_ORDER")}}const finalRowToLock=lodash_1.default.last(rowsToLock);if(finalRowToLock){__trx2FinalLockedRow.set(trx,finalRowToLock)}__cleanCompletedTransactions();return finalLockedRow}function __checkRowIsOrderedBeforeOrEqualToRow(row1,row2){const row1Index=lodash_1.default.findIndex(__tableLockingOrder,(tableName=>tableName===row1.tableName));const row2Index=lodash_1.default.findIndex(__tableLockingOrder,(tableName=>tableName===row2.tableName));if(row1Index<row2Index){return true}else if(row1Index>row2Index){return false}return row1.id<row2.id||row1.id===row2.id}function __cleanCompletedTransactions(){const transactionsToDelete=[];__trx2FinalLockedRow.forEach(((value,trx)=>{if(trx.isCompleted()){transactionsToDelete.push(trx)}}));lodash_1.default.forEach(transactionsToDelete,(trx=>{__trx2FinalLockedRow.delete(trx)}))}async function __lockRows(trx,rows){const queryStrings=lodash_1.default.map(rows,(row=>__genLockRowQueryString(trx,row)));const fullQueryString=`DO $$BEGIN\n${queryStrings.join("\n")}\nEND$$;`;await trx.raw(fullQueryString)}function __genLockRowQueryString(trx,row){return`  PERFORM id FROM ${row.tableName} WHERE id=${trx.raw("?",[row.id])} FOR UPDATE;`}